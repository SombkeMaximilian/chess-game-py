# -*- coding: utf-8 -*-

import pygame as p
import math

import engine
import graphics


def main():
    
    """
    Handles inputs and updating the game state on screen.
    """
    
    p.init()
    
    # set up pygame
    totalWidth = WIDTH + BORDERS["l"] + BORDERS["r"]
    totalHeight = WIDTH + BORDERS["t"] + BORDERS["b"]
    window = p.display.set_mode((totalWidth, totalHeight))
    window.fill(p.Color("white"))
    clock = p.time.Clock()
    
    # font for the move log
    font = p.font.Font("fonts/Segoe UI.ttf", 12)
    
    # generate initial gamestate
    gamestate = engine.GameState()
    legalMoves = gamestate.generateLegalMoves()
    newGameState = False
    
    # load images here, only needs to be done once
    images = graphics.loadImages()
    
    selectedSquare = ()
    moveCoordinates = []
    
    active = True
    gameover = False
    
    # start running the game, this section is executed once per frame
    while active:
        
        # event queue
        for event in p.event.get():
            
            # stop the while loop if the user exits the game
            if event.type == p.QUIT:
                
                active = False
            
            # mouse presses
            if event.type == p.MOUSEBUTTONDOWN and not gameover:
                
                clickCoordinates = p.mouse.get_pos()
                clickY = math.floor((clickCoordinates[0] - BORDERS["l"]) / SQUARE_SIZE)
                clickX = math.floor((clickCoordinates[1] - BORDERS["t"]) / SQUARE_SIZE)
                mouseClick = (clickY, clickX)
                
                # unselecting by clicking again
                if mouseClick == selectedSquare:
                    
                    selectedSquare = ()
                    moveCoordinates = []
                
                # check if click is inside the chess board
                elif mouseClick[0] in range(8) and mouseClick[1] in range(8):
                    
                    selectedSquare = mouseClick
                    moveCoordinates.append(reversed(selectedSquare))
                
                # move piece if 2 clicks in different squares were made
                if len(moveCoordinates) == 2:
                    
                    move = engine.Move(*moveCoordinates, gamestate.board)
                    
                    # check of the move complies with the rules
                    if move in legalMoves: 
                        
                        # get the move generated by the engine's functions for
                        # legal moves, needed for pawn promotion, etc.
                        move = legalMoves[legalMoves.index(move)]
                        
                        gamestate.performMove(move)
                        newGameState = True
                                                
                        selectedSquare = ()
                        moveCoordinates = []
                    
                    # selecting a different square if not a legal move
                    else:
                        moveCoordinates = [reversed(selectedSquare)]
                        
        
            # key presses
            if event.type == p.KEYDOWN:
                
                # u is the hotkey for undo
                if event.key == p.K_u:
                    
                    gamestate.undoMove()
                    newGameState = True
                    gameover = False
                    
                # r is the hotkey for resetting the board
                if event.key == p.K_r:
                    
                    gamestate = engine.GameState()
                    legalMoves = gamestate.generateLegalMoves()
                    newGameState = False
                    gameover = False
                    selectedSquare = ()
                    moveCoordinates = []
        
        # generate new legal moves if the gamestate changed
        if newGameState == True:
            
            legalMoves = gamestate.generateLegalMoves()
            newGameState = False
        
        graphics.drawGameState(window, gamestate, legalMoves, selectedSquare, 
                               images, font, totalWidth, totalHeight,
                               HEIGHT, SQUARE_SIZE, BORDERS, DIM)
        
        # end of game screen
        if gamestate.checkmate:
            
            gameover = True
            winner = [player for player in gamestate.players if player != gamestate.turnPlayer][0]
            graphics.drawGameoverText(window, winner + "wins", images, WIDTH, BORDERS)
            
        elif gamestate.stalemate:
            
            gameover = True
            graphics.drawGameoverText(window, "stalemate", images, WIDTH, BORDERS)
        
        clock.tick(FPS)
        p.display.flip()
    
    # close the window
    p.quit()
    
    
if __name__ == "__main__":
    
    """
    Global variables for displaying the chess board.
    WIDTH and HEIGHT of the board, possibly allow the user to change this later.
    BORDERS around the board for extra features.
    DIM = Dimensions of the board is always 8.
    Each row and column has 8 squares of size SQUARE_SIZE.
    FPS the game runs at, possibly allow the user to change this later.
    """
    
    WIDTH = 512
    HEIGHT = 512
    BORDERS = {"l": 25, "r": 350, "t": 25, "b": 25}
    DIM = 8
    SQUARE_SIZE = int(WIDTH / DIM)
    FPS = 30
    
    main()